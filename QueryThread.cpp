//  QueryThread.cpp
//  Cole Boyer, Patrick Landis, David Sherbinin
//  cojboyer@ucsc.edu, pdlandis@ucsc.edu, dsherbin@ucsc.edu
//  CMPS 109 Winter '17 Group Project
//
//  Function definitions for the QueryThread class.

#include "QueryThread.h"

QueryThread::QueryThread(map<string, vector<Fact>>* f,
        map<string, vector<Rule>>* r, string n, vector<string> p, int id,
        pthread_mutex_t* cout_m, pthread_mutex_t* write_m) {
    kb = f;
    rb = r;
    name = n;
    params = p;
    tid = id;
    res = new vector<Fact>();
    cout_mtx = cout_m;
    write_mtx = write_m;
}

QueryThread::~QueryThread() {
    delete res;
}

void* QueryThread::threadMainBody(void* arg) {
    pthread_mutex_lock(cout_mtx);
    std::cout << "thread " << tid << " started\n";
    pthread_mutex_unlock(cout_mtx);
    
    vector<Fact> results;
    
    auto fi = kb->find(name);
    if(fi != kb->end())
        results = queryFacts(name, params);
        //return queryFacts(name, params);
    
    auto ri = rb->find(name);
    if(ri != rb->end())
        //res = queryFacts(name, params);
        results = queryFacts(name, params); // CHANGE TO RULES BEFORE MERGE
        //return queryRules(name, params);
    
    //res->insert(res->end(), results.begin(), results.end());
    
    //std::cout << "Couldn't find a match in facts or rules.\n";
    pthread_mutex_lock(cout_mtx);
    std::cout << "thread " << tid << " ending\n";
    pthread_mutex_unlock(cout_mtx);
    return nullptr;
}

vector<Fact> QueryThread::queryFacts(string f_name, vector<string> params) {
    //std::cout << "querying facts...\n";
    int nParams = params.size();
    vector<QueryParam> qParams;
    vector<Fact> results;
    
    // Build the list of query parameters from the raw parameter input.
    // Loop through each given param string.
    for(unsigned int i = 0; i < params.size(); i++) {
        bool dupe = false;
        // Compare the given string to the values already converted into QueryParams.
        for(unsigned int j = 0; j < qParams.size(); j++) {
            if(params[i] == qParams[j].given_name) {
                // If the names match, we have multiple params representing the same value, I.E. Employer($A,$A).
                dupe = true;
                qParams[j].pos.push_back(i);
                break;
            }
        }
        if(!dupe){
            qParams.push_back(QueryParam(params[i], i));
        }
    }
    
    for(unsigned int i = 0; i < (*kb)[f_name].size(); i++) {
        if(checkFact((*kb)[f_name][i], qParams, nParams)) {
            //std::cout << "found a fact\n";
            results.push_back((*kb)[f_name][i]);
        }
    }
    
    return results;
}

// Return true if the given Fact meets the requirements of the given QueryParam list.
// IMPORTANT: this function treats repeat variable situations, such as ($A,$A) in a specific manner:
//              If ($A,$A) are the original params, $A must equal $A.
//              However, if ($A,$B) are the params, $A may or may not equal $B. ($A,$A) will return a subset of ($A,$B).
//              This behavior can be changed (fixed?) later by running another check through the queryParams.
// Params:
//      f: The specific Fact to check against.
//      qp: A list of QueryParams, as generated by queryFacts().
//      np: The actual number of parameters, after accounting for qp's pos system. (That is, not necessarily equal to qp.size)
// Returns:
//      true if the fact meets the requirements defined by the QueryParams, false otherwise.
bool QueryThread::checkFact(const Fact& f, const vector<QueryParam>& qp, int np) {
    if(f.vals.size() != (unsigned int)np) {
        return false; // Check that lengths match.
    }
    
    vector<QueryParam> current_vals(qp); // Make copy of parameters, so we can edit this copy.
    
    // Loop through each value of the fact.
    //for(unsigned int i = 0; i < f.vals.size(); i++) {
        //std::cout << "[DEBUG]: number of values to check: " << f.vals.size() << std::endl;
    //}

    for(unsigned int i = 0; i < f.vals.size(); i++) {
        //std::cout << "[DEBUG]: number of values to check: " << f.vals.size() << std::endl;
        // Note that i is the position of the fact's value.
        // I.E. for Father(Roger,George), Roger is in position i = 0, George in i = 1.

        // Find the corresponding QueryParam by looping through
        // the list until we get a position match.
        QueryParam* comp = NULL;
        for(unsigned int j = 0; j < current_vals.size() && comp == NULL; j++) {
            for(unsigned int k = 0; k < current_vals[j].pos.size(); k++) {
                if((int)i == current_vals[j].pos[k])
                    comp = &current_vals[j];
            }
        }
        // Given that we already checked the size of the param list, we don't need to test for NULL here.
        
        
        // Wildcard values must match values of the same variable, but can be anything.
        // If we don't already have a value here, just set it to whatever.
        if(comp->wildcard && comp->value == "") {
            comp->value = f.vals[i];
        }
        else {
            if(comp->value != f.vals[i])
                return false;
                // The value in this position does not match the expected value.
                // This can occur if we're searching for a literal, or if we have
                // repeated parameters.
        }
    }
    return true;
}
