//  SRI_Engine.cpp
//  Cole Boyer, Patrick Landis, David Sherbinin
//  cojboyer@ucsc.edu, pdlandis@ucsc.edu, dsherbin@ucsc.edu
//  CMPS 109 Winter '17 Group Project
//
//  Function definitions for the SRI engine.

#include "SRI_Engine.h"


// Adds a fact to the SRI engine. Searches the KB for duplicate entries, and fails
// with a message to stdout if a duplicate exists.
// Params:
//      name: The name of the fact to be added. Not necessarily unique to other facts. Example: "Father"
//      params: A list of parameters associated with the fact. Example: "[Roger, Fred]"
void SRI_Engine::addFact(string name, vector<string> params) {
    // Check for duplicate entries.
    for(auto i: facts[name]) {
        if(i.vals.size() != params.size()) continue; // Not a match.
        bool entries_match = true;
        for(int j = 0; j < i.vals.size(); j++) {
            //std::cout << "comparing " << params[j] << " and " << i.vals[j] << std::endl;
            if(params[j] != i.vals[j]) {
                entries_match = false; // Not a match.
                break;
            }
        }
        if(entries_match) {
            std::cout << "Found a duplicate entry for that fact, so it was ignored.\n";
            return;
        }
    }

    // Add to fact list.
    facts[name].push_back(Fact(params));
}

// Work in progress.
void SRI_Engine::addRule(string name, string format, bool type, vector<string> facts) {
    // TODO: Check for duplicates
    
    rules[name].push_back(Rule(format, type, facts));
}


// Return true if the given Fact meets the requirements of the given QueryParam list.
// IMPORTANT: this function treats repeat variable situations, such as ($A,$A) in a specific manner:
//              If ($A,$A) are the original params, $A must equal $A.
//              However, if ($A,$B) are the params, $A may or may not equal $B. ($A,$A) will return a subset of ($A,$B).
//              This behavior can be changed (fixed?) later by running another check through the queryParams.
// Params:
//      f: The specific Fact to check against.
//      qp: A list of QueryParams, as generated by queryFacts().
//      np: The actual number of parameters, after accounting for qp's pos system. (That is, not necessarily equal to qp.size)
// Returns:
//      true if the fact meets the requirements defined by the QueryParams, false otherwise.
bool SRI_Engine::checkFact(const Fact& f, const vector<QueryParam>& qp, int np) {
    if(f.vals.size() != np) {
        //std::cout << "[DEBUG]: Fact doesn't match because the number of parameters don't match the number of values.\n";
        return false; // Check that lengths match.
    }
    
    vector<QueryParam> current_vals(qp); // Make copy of parameters, so we can edit this copy.
    
    /*
    std::cout << "current_vals: " << std::endl;
    for(auto i : current_vals) {
        std::cout << i.given_name << " at positions ";
        for(auto j : i.pos)
            std::cout << j << ",";
    }
    */
    
    // Loop through each value of the fact.
    for(int i = 0; i < f.vals.size(); i++) {
        std::cout << "[DEBUG]: number of values to check: " << f.vals.size() << std::endl;
        // Note that i is the position of the fact's value.
        // I.E. for Father(Roger,George), Roger is in position i = 0, George in i = 1.

        // Find the corresponding QueryParam by looping through
        // the list until we get a position match.
        QueryParam* comp = NULL;
        for(int j = 0; j < current_vals.size() && comp == NULL; j++) {
            for(int k = 0; k < current_vals[j].pos.size(); k++) {
                if(i == current_vals[j].pos[k])
                    comp = &current_vals[j];
            }
        }
        // Given that we already checked the size of the param list, we don't need to test for NULL here.
        
        
        // Wildcard values must match values of the same variable, but can be anything.
        // If we don't already have a value here, just set it to whatever.
        if(comp->wildcard && comp->value == "") {
            std::cout << "[DEBUG]: comp->value == \"\" in this wildcard, so we're taking the value " << f.vals[i] << std::endl;
            comp->value = f.vals[i];
        }
        else {
            std::cout << "[DEBUG]: comparing " << comp->value << " to " << f.vals[i] << std::endl;
            if(comp->value != f.vals[i])
                return false;
                // The value in this position does not match the expected value.
                // This can occur if we're searching for a literal, or if we have
                // repeated parameters.
        }
    }
    return true;
}

// Get a list of matching facts with the given name and parameters.
// Searches through all matching facts found in the given name's category.
//
// For example, calling queryFacts with f_name = Father will iterate through
// all Facts stored in the KB with the name Father, compare them to the given
// list of requirements, and return a list of Facts that satifisy them.
// Params:
//      f_name: The Fact name-type to check.
//      params: A list of string parameters used to call the query.
//              For example, if Father($A,George) is the query, params = ["$A", "George"].
//              Note that the $ is retained for 'wildcard' parameters to denote them as such.
//
vector<Fact*> SRI_Engine::queryFacts(string f_name, vector<string> params) {

    int nParams = params.size();
    vector<QueryParam> qParams;
    vector<Fact*> results;
    
    // Build the list of query parameters from the raw parameter input.
    // Loop through each given param string.
    for(int i = 0; i < params.size(); i++) {
        bool dupe = false;
        // Compare the given string to the values already converted into QueryParams.
        for(int j = 0; j < qParams.size(); j++) {
            if(params[i] == qParams[j].given_name) {
                // If the names match, we have multiple params representing the same value, I.E. Employer($A,$A).
                //std::cout << "[DEBUG]: found a duplicate param\n";
                dupe = true;
                qParams[j].pos.push_back(i);
                //std::cout << "[DEBUG]: new pos list contains: ";
                //for(auto k : qParams[j].pos) {  std::cout << k << ","; }
                //std::cout << std::endl;
                break;
            }
        }
        if(!dupe) qParams.push_back(QueryParam(params[i], i));
    }
    
    //std::cout << "[DEBUG]: qParams contains: " << std::endl;
    //for(auto i : qParams) {
    //    std::cout << "[DEBUG]: " << i.given_name << " in positions ";
    //    for(auto j : i.pos) std::cout << j << ", ";
    //    std::cout << std::endl;
    //}
    
    //std::cout << "[DEBUG]: Checking each Fact of type " << f_name << std::endl;
    //for(auto i : facts[f_name]) {
    for(int i = 0; i < facts[f_name].size(); i++) {
        
        //for(auto x : i.vals) { std::cout << x << ","; }
        //std::cout << std::endl;
    
        if(checkFact(facts[f_name][i], qParams, nParams)) {
            results.push_back(&facts[f_name][i]);
            //std::cout << "Matched fact\n";
            std::cout << "matches: " << results.size() << std::endl;
        }
        //else std::cout << "Couldn't match fact\n";
    }
    std::cout << "matches: " << results.size() << std::endl;
    
    std::cout << "results in fact[" << f_name << "]: " << std::endl;
    //for(auto i : results) {
    for(int i = 0; i < results.size(); i++) {
        for(int j = 0; j < results[i]->vals.size(); j++)
            std::cout << results[i]->vals[j] << ",";
        //for(auto j : i->vals) {
        //    std::cout << j << ",";
        //}
        std::cout << std::endl;
    }
    
    return results;
}



// ----------------------------
// Rules / rule inferrence mess section
// ----------------------------

// r_name is the rule name
// params is the list of named variables/parameters used in the invocation
vector<Fact*> SRI_Engine::invokeRule(string r_name, vector<string> params) {
    
    // Example usage:
    //  defined with RULE GrandFather($X,$Y):- AND Father($X,$Z) Parent($Z,$Y)
    //  queried with INFERENCE GrandFather($A,$B)
    
    // What needs to happen here:
    //  LOOP THROUGH EACH "GrandFather" RULE: can have multiple definitions.
    //  for each rule:
    //      for the first fact defined in the rule, compare param to rule format saved.
    //
    //
    
    
    
    vector<Fact*> results;
    /*
    int nParams = params.size();
    vector<QueryParam> qParams;
    // Build the list of query parameters from the raw parameter input.
    // Loop through each given param string.
    for(int i = 0; i < params.size(); i++) {
        bool dupe = false;
        // Compare the given string to the values already converted into QueryParams.
        for(int j = 0; j < qParams.size(); j++) {
            if(params[i] == qParams[j].given_name) {
                // If the names match, we have multiple params representing the same value, I.E. Employer($A,$A).
                //std::cout << "[DEBUG]: found a duplicate param\n";
                dupe = true;
                qParams[j].pos.push_back(i);
                //std::cout << "[DEBUG]: new pos list contains: ";
                //for(auto k : qParams[j].pos) {  std::cout << k << ","; }
                //std::cout << std::endl;
                break;
            }
        }
        if(!dupe) qParams.push_back(QueryParam(params[i], i));
    }
    // qParams is now a list of given_names, the names provided by the user when querying,
    // and pos, a list of positions within the initial call the values occured at.
    */

    vector<Rule>* rl = &(rules[r_name]);
    Rule* r = &(rl->front()); // POPPING FIRST ENTRY FOR TESTING -- MULTIPLE RULES OF THE SAME NAME WONT WORK.
    //for(int i = 0; i < rl->size(); i++) {
    
    if(!r) { std::cout << "No rule by that name.\n"; return results; }


    // Build a mapping structure so we know what the "actual" params being used
    // in place of the rule params.
    // For example, if rule R($X,$Y) invoked with ($A,George), this map will contain:
    //  [$X] = $A
    //  [$Y] = George
    map<string,string> rule_param_to_calling_param;
    for(int i = 0; i < r->params.size(); i++)
        rule_param_to_calling_param[r->params[i]] = params[i];
    
    
    
    for(int i = 0; i < r->facts.size(); i++) {
        
        vector<string> factParams(r->facts[i].params); // Copy parameter format for editing
        
        // Iterate through each parameter and try to match it to a previous parameter.
        for(int j = 0; j < factParams.size(); j++) {
            auto it = rule_param_to_calling_param.find(factParams[j]);
            if(it != rule_param_to_calling_param.end())
                factParams[j] = it->second;
        }
        // factParams now contains the list of calling params where
        // any previously defined param of the rule is replaced with
        // a calling param, if available.
        
        queryFacts(r->facts[i].name, factParams);
    }
}

/*
void SRI_Engine::evaluateRule(string r_name, vector<string> params) {
    Rule r = rules[r_name];
    
    vector<string> rule_param_names;
    int i = 0;
    bool capturing = false;
    string pname = "";
    while(r.format[i] != ')') {
        if(r.format[i] == '$') {
            capturing = true;
            continue;
        }
        else if (r.format[i] == ',')
            if(pname != "") rule_param_names.push_back(pname);
            capturing = false;
        }
        if(capturing)
            pname += r.format[i];
    }
    if(pname != "") rule_param_names.push_back(pname);

    map<string, string> param_map; // Maps the given parameters to those defined in the rule.

    

}
*/
// ----------------------------
// end mess
// ----------------------------

// This is a debug function that dumps all facts and rules to the console.
// Rule printing currently wonky while I mess with the rule definition.
void SRI_Engine::print() {
    // Print all facts
    for(auto i : facts) {
        std::cout << "facts[" << i.first << "] = \n";
        for(auto j : i.second) {
            for(auto k : j.vals)
                std::cout << k << ",";
            std::cout << std::endl;
        }
        std::cout << std::endl;
    }
    
    // Print all rules
    for(auto i : rules) {
        std::cout << "rules[" << i.first << "] = \n";
        for(auto j : i.second) {
            std::cout << "format: " << j.format << std::endl;
            //for(auto k : j.fact_names)
            //    std::cout << k << ",";
            std::cout << std::endl;
        }
        std::cout << std::endl;
    }
};
